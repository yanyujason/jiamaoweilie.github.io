
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="使用面向对象语言的（如Java，C#, Objective-C）软件开发人员创建一系列相关的类来开发软件。每个类定义了不同类型的对象，各个对象之间相互合作，提供了软件所需的功能。 根据“单一职责原则”或者“关注点分离”原则，精心设计的类的对象做且只做一件事件。一些类体现了技术领域的概念， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jiamaoweilie.github.io">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jiamaoweilie.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/10/30/model-in-color/">[彩色建模【译】](http://www.step-10.com/SoftwareDesign/ModellingInColour/index.html)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-30T11:49:46+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:49 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>使用面向对象语言的（如Java，C#, Objective-C）软件开发人员创建一系列相关的类来开发软件。每个类定义了不同类型的对象，各个对象之间相互合作，提供了软件所需的功能。</p>

<p>根据“单一职责原则”或者“关注点分离”原则，精心设计的类的对象做且只做一件事件。一些类体现了技术领域的概念，例如用户界面、页面、控件、数据库连接、搜索结果、事务、网络连接、服务、消息。另一些类体现了问题域（problem domain）的概念。问题域的关注点是软件的消费者或用户。例如，如果开发一个订单管理系统，我们将定义一些问题域的类来代表消费者、订单和产品。</p>

<p>我们称这些类为业务描述对象或者“真实世界”建模，但是他们有一个更加普遍接受的名称：问题域类（problem domain classes）或者单纯的领域类（domain classes）。</p>

<p>换句话说，问题域类映射的观念、思路和规则是软件开发中剥离了正在使用的具体技术到后留下的东西。它们形成了软件的心脏，是传统面向对象应用中最重要的逻辑层。</p>

<p>在多数基于组件或者面向服务的软件中，问题域类帮助推动业务服务和组件的定义和组织。它们还推动了问题域类用于组件或服务实现的设计。</p>

<p>不管是传统的，基于组件的，或者是面向服务的软件，几乎所有的现代软件架构都需要很多技术类来支持每个问题域类。如图1：</p>

<ul>
<li>用户界面类（User interface classes），通常是传统MVC（Model-View-Controller）和命令模式（Command patterns）的变种，对应软件使用者对问题领域对象的显示和操作。</li>
<li>持久化类（Persistence classes），或者持久化机制（例如Hibernate，ADO.Net Entity Framework，and Core Data）的配置文件，用来处理问题域对象到文件或者关系型数据库的映射、存储、检索。</li>
<li>服务层类和它们的参数提供了其他组件和外部系统通过网络与问题域对象集成和交互的方法。</li>
</ul>


<p><img src="http://www.step-10.com/SoftwareDesign/ModellingInColour/images/PDClass.png" alt="PD Class" /></p>

<p>图1. 一个PD类需要大量技术类的支持</p>

<p>虽然不是所有的问题域类都需要如此多的技术类支持，但是有些重要的问题域类可能需要更多的支持。因为它们出现在多个视图，参与了多个服务，以不同的方式在多个时间点持久化。由于各个问题域类之间的关系和依赖，整个事情将更加复杂，例如销售给客户的产品或者供应商交付的项目。在不考虑任何相关的单元、集成、和系统测试类和脚本的情况下，问题域对象支持类的平均数量可以轻松到达十几个或者更多。</p>

<p>尽管有最佳实践的封装，通过支持类对问题域类的更改经常一波三折。小型重构（例如重命名操作）可以通过现代化的IDE工具自动化实现，例如Eclipse、NetBeans、Visual Studio、和 XCode等。更加重要的更改（例如删除属性，改变一对一关系对一对多，是关系双向）通常仍然需要人工更新和重新测试很多类、配置文件、和运行环境支持等。</p>

<p>虽然许多改变是不可避免的，但是学习那些能够帮助我们尽早识别出更强健的问题域类的模式或策略显然是非常必要的。这正是‘彩色建模（modeling in color）’技术提供的东西，它针对于商业和I.T.产业的组件和系统。</p>

<p>Peter Coad在以前关于面向对象分析、设计模式和策略的工作中创建了‘彩色建模’技术的雏形，并在随后几年做了深入研究和重新定义。1997年，该技术首次用于新加坡的一个Java技术栈的软件开发项目。1999年，Peter Coad，与合著者Eric Lefebvre和Jeff De Luca，在他们出版的书《Java Modeling in Color with UML》中介绍了‘彩色建模’技术。对该技术和相关FDD（Feature-driven development）流程的贡献者还有Phil Bradley、Jon Kern、Mark Mayfield、David North和我。</p>

<p><strong>类建模</strong></p>

<p>彩色建模的模型和策略源于类建模的想法。</p>

<p>在业务系统，不论在什么领域，那些典型的问题域类总会一直出现。举个例子，我们几乎总是能发现一些代表不同类别业务（例如销售、订单、租赁、订票、计划的事件，交付，提交，批准，查询等）的交易或交互的类。然后，我们通常找到塑造了参与这些业务交易或交互的当事人、地点和事务的类，进行购买、销售、订购、批准等的人或者组织。此外，那些被购买、销售、或批准的产品或服务等需要被展示，例如在商店、银行分行、网站等这些事情发生的地方。这些一般类不是特定于某一个域。无论问题域是银行业、保险业、零售业、制造业、人力资源、旅游业、交通运输业，还是什么别的，那些典型的类总是持续出现。不同种类的类是独立于领域的，他们是领域无关的（domain neutral）。</p>

<p>这些类不止出现在商业系统。在工业系统中，我们有类来建模特定类型的事件和时间间隔，例如传感器或开关的状态变化，进行测量的时间段，一件设备性能上升到特定阶段需要的时间等等。它们同样非常典型，当事人、地点、和事务类分别代表了传感器和设备本身、监管设备或问题的处理过程的操作员、以及不同种类设备的地点等等。</p>

<p>一个粗略分类中的所有类之间的相似性可能不够接近，不能被概括为一个有用的超级类或者Java/C#中的接口。然而，他们之间的相似性已经足以帮助指导我们设计中问题域类的选择和定义。在彩色建模中，我们称这些粗略分类叫类原型（class archetypes），术语原型据说代表了比较柔和的模式，因此是比刻板印象更合适的术语。彩色建模识别出四个类原型，并分别为其分配一种颜色。</p>

<p><img src="http://www.step-10.com/SoftwareDesign/ModellingInColour/images/FourClassArchetypesLinkedBare.jpg" alt="FourClassArchetypesLinkedBare" /></p>

<p>图2：彩色建模为问题域定义了四个类原型</p>

<p>四个类原型如图2所示：</p>

<ul>
<li><a href="http://www.step-10.com/SoftwareDesign/ModellingInColour/Moment-Interval.html">时刻/间隔（Moment-Interval）</a>类原型，用于模拟需要处理并跟踪业务和法律原因的事情，或者在某个时刻或者某个时间间隔发生的事情。<a href="http://www.step-10.com/Books/JMCUBook.html">[Coad99]</a></li>
</ul>


<p>MI类原型的例子包括销售、租赁、订单、旅程、飞行、会议、预定、谋杀、传感器读取、报警激活等。</p>

<p>MI类原型是粉红色（淡红色）。它表示我们的软件感兴趣的事件，以及人物、地点、事件之间的交互和业务交易。</p>

<p>换句话说，如果发生，它是粉红色的！粉红色发生！</p>

<ul>
<li><a href="http://www.step-10.com/SoftwareDesign/ModellingInColour/Role.html">角色</a>类原型塑造了一个参与人（人或者组织）、地点或事件的参与方式。<a href="http://www.step-10.com/Books/JMCUBook.html">[Coad99]</a></li>
</ul>


<p>角色类的示例包括申请人、账号持有人、审批人、领航员、收银员、客户、供应商、运营商等。</p>

<p>角色类是淡黄色的。它表示参与到软件（发生的）时刻间隔的人、地点、和事物被识别的方式。角色是我们能够做到和授权的一组责任和义务。当我们希望演绎某种角色的时候，我们通常说我们带了一种或者多种不同的帽子。角色类塑造了这些帽子，并且这些帽子总是黄色的。</p>

<p>我们带黄帽子哦！</p>

<ul>
<li><a href="http://www.step-10.com/SoftwareDesign/ModellingInColour/PartyPlaceThing.htm">PPT（Party, Place, Thing）</a>类原型演绎了某些扮演不同角色的人或者物。<a href="http://www.step-10.com/Books/JMCUBook.html">[Coad99]</a></li>
</ul>


<p>当事人(Party)类的例子是人或者组织。地点类的例子包括办公室、商店、仓库、机场、银行分行等。事物类是那些识别诸如私人汽车、飞机、DVD、书籍、设备等个体物品的类。</p>

<p>PPT类是淡绿色的。如果角色类是可以戴的各式各样的（黄色）帽子，那么PPT类就是戴那些帽子的人。显而易见，人是可以扮演角色的，但是地点也同样可以。一个建筑物可以扮演餐厅的角色，也可以扮演犯罪现场的角色。同样，事物也可以扮演角色，比如在制造过程中的角色，或者在销售过程中的角色。如果你可以与它交谈、被它带到法庭、移动它、踢它，那么这个东西就很可能是一个绿色的PPT类。</p>

<p>帽子是黄色的，但是戴帽子的家伙是绿色的哦！</p>

<ul>
<li><a href="http://www.step-10.com/SoftwareDesign/ModellingInColour/Description.html">描述</a>类原型塑造了一个类条目式（catalog-entry-like）的描述。它是一个一次又一次被应用的值得集合。它还提供对于对其描述的所有事物的集合的行为。<a href="http://www.step-10.com/Books/JMCUBook.html">[Coad99]</a></li>
</ul>


<p>它的例子代表了所有类型的产品描述。蓝色和绿色之间的区别是电影和记录电影的DVD之间的区别。</p>

<p>描述类是淡蓝色的。描述类根据不同的值区分或者标记其他东西，通常这些东西是当事人、地点或者事物对象，偶尔也会有MI类。公司工作的行业是一个描述类对象。展厅中展示的汽车模型是一个描述类对象。亚马逊上销售的图书是一个描述类对象。</p>

<p>类似的，你用来区分这些东西的标签总是蓝色的哦！</p>

<p><strong>典型责任</strong></p>

<p>因为同一类原型基本上塑造相同的事物，他们的对象通常需要记住相同的信息，并执行类似的任务。举个例子，MI类的对象通常记录事物发生的日期和时间，并告诉您是否成功完成。角色类的对象通常需要记住它们已经被授权执行某种角色的某种标识符，比如飞行员的许可证号等。</p>

<p>通过列举大量各个类原型的例子，经过稍微的概括，我们可以为每个类原型创建一个典型操作和属性的粗略清单。列表中的每个属性或者操作都代表了我们为该类原型定义的典型操作或属性（见图3）。</p>

<p><img src="http://www.step-10.com/SoftwareDesign/ModellingInColour/images/FourArchetypesWithContentSideBySide.gif" alt="FourArchetypesWithContentSideBySide" /></p>

<p>图3：四个类原型及其典型属性和操作</p>

<p>很少有某个特定的模型能够列举该类原型所拥有的全部属性或者操作。如果某个特定的典型属性或操作与一个特定的类不相关，我们就简单的不为该类定义相应的属性或者操作。例如，对于有些需要相对优先级概念的MI类，我们就会有优先级属性的等价物，而对于没有该属于的类，我们就不做定义。</p>

<p>类原型的每个典型属性或者操作可能匹配特定类上的多个属性或操作。例如，一个具有复杂生命周期的MI类可能同时需要最大和最小状态属性。</p>

<p>这些典型属性或者操作列表也不是详尽的。我们定义的类将涉及一些不在相关原型列表中的属性或者操作。例如，一个当事人类中构建的对象可能包含一个保留日期，来指示由于某些法律需求，数据必须在何时被销毁。而PPT类中并不存在该属性。</p>

<p>这些类原型的典型属性和操作，只是为我们实际在定义类时需要的属性和操作提供了特定建议。它们为我们在创建或者审视一个类应属于某个类原型提供了线索和暗示。</p>

<p>换句话说，类原型的每个操作或属性是一个对特定类原型的典型责任的提示。如果我们可以识别出问题域中的类原型类，那么这些典型的操作和属性列表就提供给我们一个检查列表，来帮助我们来或在我们的模型中审查承担合适地责任。例如，每个类原型中的第一个属性是某种标示或者参考号码。这提示我们，属于任何类原型的对象都有责任使他们与其所代码的真实世界相匹配。例如，现金销售对象通常将收据编号作为参考编号，使其可以与其完成特定交易相匹配。出纳员对象可能需要记住用户名来匹配他们在其登录时的人类对象，等等。</p>

<p>事实上，类原型具有名称，典型属性列表和典型操作类别使用统一建模语言（UML）以图像的方式来表示类原型。我们会重复利用图3所示的一些属于原型类的标记。</p>

<p><strong>原型建模</strong></p>

<p>为了重复履行其职责，对象需要频繁的与同一个或者不同类之间的对象合作。因此，原型类中的许多典型责任意味着与其他类的典型关联，和与其他类的对象之间的典型交互方式。这些典型关联和它们对象之间的典型交互方式使得我们能够将类原型合并成原型、问题域对象模型。这些模型原型或者中立域组件作为我们分析和定义模型的常用模式。</p>

<p><img src="http://www.step-10.com/SoftwareDesign/ModellingInColour/images/FourClassArchetypesLinked.jpg" alt="FourClassArchetypesLinked" /></p>

<p>图4：四类原型链接到基本模型原型</p>

<p><img src="http://www.step-10.com/SoftwareDesign/ModellingInColour/images/DNC.gif" alt="DNC" /></p>

<p>图5：基本模型原型将参与人、地点、事件中扩展的详细中立域组件</p>

<p>使用中立域组件（Domain Neutral Component (DNC)）可以真正帮助我们提高构建问题域对象模型的速度。从识别感兴趣的特定问题域中的一个或多个时刻间隔类开始，然后依次对这些类使用DNC覆盖，逐步利用DNC中的条目替换特定问题域中条目，或者删除问题域中没有等价物的条目或模型不需要的条目。</p>

<p>DNC在审查现有模型中也非常有用。首先，通过分配原型到每个类来在模型中显示颜色。然后调整和证明DNC中的偏差和遗漏。但是，请记住，DNC是一种模型，但不是元模型（meta-model）。元模型定义了一系列创建兼容模型的严格规则。DNC不是这样的，它更加宽松，是一套建议和提示。在许多情况下，一些与模型的合理偏差是需要、期望、和必要的。</p>

<ul>
<li><a href="http://www.step-10.com/SoftwareDesign/ModellingInColour/dnc.html">阅读更多关于原型使用和DNC的材料&hellip;</a></li>
</ul>


<p>当我们第一次遇到它时，很多人对DNC在实践中的适用性提出了怀疑。我也拥有同样的问题。有两个原因使得我认为DNC比初始预期的更加适用。首先，大多数的商业系统都适用于特定的商业事件或活动，或者某种商业流程的事件或活动。MI模型就塑造了这些商业事件和活动。对于每个商业事件和活动，通常以不同的方式设计不同的人或组织。这些事件和活动通常发生在某些地方，即使是在网络空间。商业事件和活动经常涉及购买、销售、分配和移动东西。角色、当事人、地点、事件塑造了谁，在哪里，和那种形式的商业事件和活动。描述模型塑造了当事人、地点、事物在商业活动中的不同集合或分类。另外，重点第一是MI，其次是角色，角色扮演者，和帮助防止集中倾向于中心事件和在更加传统实体关系图（Entity-Relationship Diagramming (ERD)）中集中更多角色扮演者的描述。</p>

<p>第二个DNC比预期更加合适的原因是我在与来自TogetherSoft，Borland和Karl Frank的一个老同事讨论是出发的一些灵感。当你退一步思考后，你会意识到DNC本质上是PPT之间的UML关联的自然扩展。MI在许多方面类似于关联类的想法，角色类与关联末端发现的角色名称的想法类似。</p>

<ul>
<li><a href="http://www.step-10.com/SoftwareDesign/ModellingInColour/FromUMLAssociationToDNC.html">阅读更多关于DNC和UNL的关联关系&hellip;</a></li>
</ul>


<p>与<a href="http://www.step-10.com/Books/JMCUBook.html">《Java Modeling in Color with UML》</a>书中提到的相比，近些年，我又补充了关于DNC的小改动，<a href="http://www.step-10.com/SoftwareDesign/ModellingInColour/DNCChanges.html">阅读更多关于这些修改&hellip;</a></p>

<p><strong>彩色建模法</strong></p>

<p>尽管在没有颜色的情况下类和模型原型也可以很有效，但是颜色编码为该技术命名。实践中证明，颜色编码是非常有效的，它可以有效减少我们使用它需要付出的代价。</p>

<p>色彩使得类原型更加易学易记。它还使得类原型在非平凡（non-trivial）UML类和序列图中更容易识别。当你初次或者比较少接触对象建模，如果呈现出一个复杂的图表会特别难以理解，而色彩将使得这些图表变得易于理解。它使得诸如项目消费者和终端用户可以更好的在建模过程中做出贡献。例如，他们可以很快识别和集中精力在粉红色的MI类所代表的他们感兴趣的业务交互中，并由此展开工作。</p>

<p>对象建模技术带来的最大好处是使得表达复杂分析和设计更加容易（上世纪90年代后期以及UML2.0规范中的那些冗长，太过于细节的建模方式中很容易被丢失和忘记的模型）。对色彩的使用能够显著增加用UML类图和时序图沟通时的能力。</p>

<p>对于那些关注为什么用彩色建模可以很好工作的人，<a href="http://www.step-10.com/SoftwareDesign/ModellingInColour/ColourCoding.html">彩色建模法</a>还有一些关于如何使用颜色，每种颜色代表哪种类原型的讨论。</p>

<p>对于大多数人来说，学习并记得下面这四种色彩就已经足够了：</p>

<p>MI类是柔和的粉红色。粉红色的发生！</p>

<p>角色类是柔和的黄色。我们总是带着黄色的帽子！</p>

<p>PPT类是柔和的绿色。戴黄帽子的家伙们都是绿的的！</p>

<p>描述类是柔和的蓝色。你给东西打上蓝色的标签！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/10/07/chi-xu-ji-cheng-zhi-wo-jian-si/">持续集成之我见（四）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-07T21:09:21+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>9:09 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>持续集成成熟度模型</h2>

<p>前面的文章介绍了持续集成的概念、工具等，那么了解这些概念、使用了这些工具就算做到了持续集成吗？答案当然不是这样。我们将在这篇文章中通过持续集成成熟度模型来探讨这个问题。</p>

<p>成熟度模型分为五个级别：</p>

<ul>
<li>入门（Base）：这个级别刚刚跟“模型”沾边，团队不再是所有的流程都要手动去操作。</li>
<li>新手（Beginner）：团队开始认真采用一些持续集成的实践，但是还在刚起步的水平。</li>
<li>中等（Intermediate）：实践已经成熟一些，能够减少错误，提高效率。</li>
<li>优化（Advanced）：团队已经远远超出同行业其他团队，而且效率非常高，能够预防错误的发生。</li>
<li>专家（Expert）：达到这个级别的要求，代价是非常昂贵的，但对某些团队来说，这是目标。</li>
</ul>


<p>其考察维度有四个，分别是构建（Building），部署（Deploying），测试（Testing），和报告（Reporting）。下面我们将从这四个维度分别讨论成熟度模型。</p>

<h3>构建</h3>

<p>以开发人员为中心的持续集成是为了从软件构建中快速得到反馈。但是当项目规模扩大后，构建管理和可控的构建流程就会变得至关重要。可控的构建流程规定了从源码检索到构建、打包、以及存储等的全过程。</p>

<p>在大多数项目的初始阶段，构建工作都是在开发机器上进行，程序员可以根据个人喜好使用IDE或者构建脚本。等项目成熟一些，构建工作就需要考虑测试，甚至发布等问题，这时候我们就开始需要一个成熟可控的构建过程。</p>

<ul>
<li>入门：有明确的构建脚本；有专门的构建机器。（业界水平）</li>
<li>新手：能够自动化构建；至少每天晚上构建一次；能够保存生成的artifacts；</li>
<li>中等：每次提交代码后构建；有依赖管理仓库；</li>
<li>优化：构建过程控制；构建集群；（目标）</li>
<li>专家：虚拟机镜像构建；提交门禁；</li>
</ul>


<p>成熟构建的第一阶段就是标准化构建过程，并且让构建有专门的机器。使用专门的机器构建意味着构建过程不会因为某个开发人员本地环境的变化而影响构建结果。构建不在开发者的机器上进行，意味着代码是从一个代码控制平台获得，并遵循一定的规则：比如每次获取每个分支的最新代码，或者打某种标签的代码。做到了这些，团队就达到了入门级。</p>

<p>新手级别是团队采取一定行动使得构建执行自动化，并且能够每天至少执行一次。构建服务器可以指挥机器按照规则pull源代码，并且执行构建脚本。</p>

<p>中等级别的团队的显著特征是开始进行依赖管理，包括对子项目的依赖和第三方库文件的依赖。团队使用依赖管理工具来追踪库文件，并且在构建时提供这些库文件，而不是将依赖放在代码库中。类似的，所依赖的子项目也是通过依赖管理工具管理和使用。构建过程会被保存（可能放在某网络服务器上，或是直接放在CI服务器上），打标签以便识别，并且定期做清理。到达这个级别，团队已经采取了持续构建，能在程序员提交代码后或者依赖变更后自己构建，并且提供有意义的反馈。一些大规模团队将使用分布式构建设备来并行处理数量众多的构建。</p>

<p>优化级别的团队将会关注对构建过程的控制，这种团队不光追踪代码和依赖的变化，也追踪构建过程的变化。对于构建过程的修改需要经过批准，因此登录到构建机器，修改构建服务器配置等操作都是被严格限制的。大规模的组织或者追求快速集成测试的组织往往需要优化级别的构建过程。随着每天构建次数的增加，或者构建环境的多样化（比如同时需要Windows设备和Linux设备），单独的构建设备就显得力不从心，我们就需要一个集群来自动选择构建集群并进行负载均衡。</p>

<p>专家级别要求团队必须能够完美地重新构建以前的发布版本。团队将使用各种各样的技术来确保每个环境的可重复性。为了运行构建过程，我们使用一些缜密的脚本，从安装操作系统开始准备构建机器，或者使用虚拟机镜像来运行版本化的构建过程。还有一些团队使用提交门禁制度使得build常绿，一旦某次提交使得构建失败，那么这次提交就会被reject掉。</p>

<h3>部署</h3>

<p>部署是将软件发布给用户，或者其他消费者。对于web应用来说，部署意味着将应用安装到一系列的web服务器上，并且更新数据库或者其他静态服务器。</p>

<p>部署的最开始一般都是手工进行，像我的上个项目，程序员将本地的部署文件拷贝到目标机器上，然后手动进行替换和安装。手工过程往往非常慢，而且特别容易出错，为了发布新的软件，开发人员和测试人员往往需要整晚加班。很多软件都需要多环节部署，而且不同环境的部署方法和步骤往往不一样，更加增大了手工部署的难度，这时候，我们就要寻找更加快捷高效的方法。</p>

<ul>
<li>入门：有少量部署脚本；（业界水平）</li>
<li>新手：自动部署到测试环境；有比较规范的部署；</li>
<li>中等：自动部署到测试和产品环境；在所有环境都有标准的流程；（目标）</li>
<li>优化：测试门禁部署；数据库的自动化部署；协调部署；</li>
<li>专家：持续部署到产品环境；</li>
</ul>


<p>入门级别的团队能在部署时使用一些的辅助性脚本，相对于纯手工部署来说，这已经是很大的进步。目前来讲，大部分团队都会使用一些辅助部署脚本，达到入门级的水平。</p>

<p>新手级别的团队能够才测试环境实现的自动部署。通过一系列脚本的帮助，系统可以一键部署到一个或者所有测试环境。这将大大减少负责部署人员的工作量，也可以减少测试团队等待部署的时间。自动部署到第一个测试环境，是持续集成的部署维度达到新手水平的标志。根据团队情况，在不影响部署的情况下，部署工作应该发生在每一次成功构建之后，或者是以固定的间隔时间进行。新手级别的另一个标志是：在各个环境上建立标准化的部署流程。虽然部署中间还充满各种变数，但是在软件开发生命周期中，尽早的部署成功不但能增加团队信心，更能及早的发现问题，增加最终部署成功的几率。</p>

<p>中等级别的团队已经能够将关注点放在产品环境的部署。产品可以一键触发部署流程，然后自动部署到产品环境，并且相应的发布版本可以做到灾难恢复。那些已经将产品自动部署的测试环境的团队，应该把中等级别作为目标，如果在所有环境中进行完全一致的部署过程，那么在生产环境部署时，会极大地减少最后一刻失败的可能性。</p>

<p>优化级别的团队的特征是：将通过质量测试检验的版本全部自动地部署到部分或全部测试环境中。例如，得到测试经理的批准后，让某个构建版本自动地安装到压力测试环境中。另外，他们还攻克了一些部署过程的难题，比如数据库部署，向内容管理系统跟新信息，提升业务敏捷工具的报告。进阶团队的另一个典型特征是，协调部署。他们不是简单的部署一次构建的结果，而是部署一系列的有内在联系的一组构建，肯能是一个应用，或者一系列Web服务。这样有助于确保系统中的所有已经被测试的组件部署到同一组生产环境。将系统部署细化成一系列的组件部署。</p>

<p>专家级别的团队追求从完全没有任何人工干预的持续部署。也就是说，在构建完成得到一个新的版本后，依次自动部署到所有一系列的测试环境，然后经过所有的自动化测试后立即自动部署该版本到生产环境，而且整个系统必须具有自动回滚和严格的监控手段，对自动化测试的要求特别高。有些Web应用甚至可以做到一个小时内完成从源代码控制到发布的全过程。在竞争激烈的当今社会，快速的发布新功能，也可以增加企业的竞争力，减轻大规模发布的风险。</p>

<h3>测试</h3>

<p>持续集成与自动化测试的层次息息相关。在很多企业中，自动化测试的重视程度很低，能力很弱，一个团队开发完一个产品，然后部署到测试环境，让测试人员进行手工测试，然后进行发布。测试人员几乎到淹没在无穷无尽的重复劳动中，特别疲惫，容易出错，而且只有发现问题的流程很长。如果团队在更加关注自动化测试，增加自动化测试脚本，他们就能很快发现问题或缺陷，从而在生产率和信心方面都会有所增加。</p>

<ul>
<li>入门：有少量自动化测试；（业界水平）</li>
<li>新手：每次构建都进行快速测试；测试失败及时通知；</li>
<li>中等：静态代码分析；具有每天至少执行一次得自动化功能测试；（目标）</li>
<li>优化：高测试覆盖率；安全扫描；基于风险的手工测试；</li>
<li>专家：100%测试覆盖率；</li>
</ul>


<p>大多数团队或多或少都有一些自动化测试，也行是少量的单元测试，或者是一些保证基本功能的测试脚本。这些测试可以帮助我们及时，快速的发现产品的基本功能性问题。入门级别的团队基本处于这个水平，刚刚开始适应自动化测试。</p>

<p>新手级别的团队应该有一套在本次构建时都会自动运行的测试。这些测试保证了软件在任何时间都是可以工作的，能够极大的增加团队信心。任何一次测试失败，系统都应该及时通知开发团队，使得问题能够及时得到修复。测试失败及时通知开发团队，也是达到新手级别的一个标志。</p>

<p>中等级别的团队具备构建时快速测试的特征外，还是得自动化测试更加多样化。一个中级级别的团队不光需要具有快速的单元测试和手工测试，还需具有自动化的功能测试，而且使用一些持续集成工具进行静态代码扫描。静态代码扫描可能不是每天进行，但是必须周期性的进行，一旦代码扫描出现一些严重的代码质量问题，就必须要阻断构建过程，待修复后才能发布产品。</p>

<p>优化级别的团队以“完整测试”为标志，每种类型的测试都要尽其所能的提供最大的作用。单元测试能够覆盖系统中的所有复杂代码和逻辑部分，功能测试能够覆盖系统中所有的重要功能，当然边界测试和随机测试也是必不可少的。同时，还需要频繁的运行静态代码扫描，并补充那些以工具执行的运行时分析和安全分析来分析那些因测试不足或无法测试而遗漏的问题。为了产品的多环境运行，测试会被分配在多种系统下运行，以提供快速的反馈。达到优化级别需要团队付出相当大的投入，但是这些投入对团队来说特别有意义，尤其对那些缺陷的成本很高且需要保持高速前进的团队来说。假如没有这些需求，一般达到中等级别已经能够满足要求。</p>

<p>专家级别团队的典型特征是追求100%的测试覆盖率。尽管100%测试覆盖率的定义在不断变化，但是它反映出至少产品的每行代码都被测试覆盖到。但是，在实际工作中，往往存在一个收益减少点，一味的追求100%覆盖往往意味着浪费。对于这些团队来说，满足并保持100%的测试覆盖率可能也是一个自豪感与动力的源泉。对于进阶级团队来说，如果曾经发现的确错过了一些非常重要的测试的话，要求100%的测试覆盖也未尚不可。但对于大多数团队来说，完全不需要刻意达到这个要求。</p>

<h3>报告</h3>

<p>报告对持续集成至关重要，它应该包括软件质量、软件内容、以及持续集成过程的相关信息。如果产生的信息无序且繁杂，我们就无法提取有用信息，那么对于软件质量的提高也没有什么作用。所以越成熟的团队，信息的可视化程度就越高，用户越容易从中得到有用信息。</p>

<ul>
<li>入门：工具生成报告；生成报告者可见；</li>
<li>新手：及时发布最近一次构建报告；团队可见；</li>
<li>中等：报告历史易追踪；报告互通性</li>
<li>优化：趋势分析报告；</li>
<li>专家：交叉分析</li>
</ul>


<p>持续集成成熟度模型的四个方面大概就是这个样子，我们在实际使用时应该根据项目自身情况，选择适合自身项目的各个维度。<del>真的实在编不下去了，等我看看书再继续充实吧</del></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/29/chi-xu-ji-cheng-san/">持续集成之我见（三）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-29T20:16:22+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:16 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>使用Jenkins搭建持续集成环境</h2>

<p>下面我们以Jenkins为例，介绍一些如何快速搭建一个持续集成环境。</p>

<h3>安装Jenkins</h3>

<p>Jenkins可以运行在多种操作系统上，这里主要介绍如何使用docker安装。首先，你需要在本机上安装<a href="http://docker.io/">docker</a>,然后执行一下命令来pull Jenkins的官方镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker pull jenkins</span></code></pre></td></tr></table></div></figure>


<p>然后运行如下命令来run该镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run -d -p 49001:8080 -v $PWD/jenkins:/var/jenkins_home -t jenkins</span></code></pre></td></tr></table></div></figure>


<p>在上述命令中，container中的 <code>/var/jenkins_home</code> 文件夹被映射到当前路径的 <code>jenkins/</code>路径下，container中的8080端口被映射到本地的49001端口。</p>

<p>至此，我们已经可以 <a href="http://localhost:49001">http://localhost:49001</a> 访问Jenkins, 并看到如下 页面。</p>

<p><img src="/images/img_for_ci/jenkins_start.jpg" alt="输入初始密码解锁Jenkins" /></p>

<p>系统要求你输入Administrator的初始密码来解锁系统，并提示了该密码的所在位置。对于docker来说，你可以输入如下操作查看该container的log，找到密码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker ps -a // 查看当前运行container</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/img_for_ci/image.jpg" alt="container的运行状态" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker logs 136d491d56d8 //数字表示Jenkins的container id</span></code></pre></td></tr></table></div></figure>


<p>然后就可以在log中找到如下的初始密码：</p>

<p><img src="/images/img_for_ci/password.jpg" alt="初始密码" /></p>

<p>然后我们可以根据页面提示，安装推荐的plugin，完成注册等初始化操作，就可以看着Jenkins的工作页面。</p>

<p><img src="/images/img_for_ci/jenkins.jpg" alt="Jenkins 首页" /></p>

<p>至此，我们就完成了所有的安装和初始化的工作。</p>

<h3>使用Jenkins</h3>

<p>对于Jenkins 2.x版本，你可以使用以前的方式创建pipeline，当然比较方便的是Pipeline as code。下面我用一个简单的例子，说明如何使用脚本创建pipeline。</p>

<h4>准备工作</h4>

<p>本文中的例子是一个简单的maven构建的java项目，所以准备工作为jenkins安装好java和maven。在Jenkins的首页点击Manage Jenkins -> Global Tool Configuration，然后如下图所示配置：</p>

<p><img src="/images/img_for_ci/jdk.jpg" alt="jdk" /></p>

<p><img src="/images/img_for_ci/maven.jpg" alt="maven" /></p>

<h4>Pipeline创建</h4>

<p>完成环境准备工作，我们就可以开始创建Pipeline。在首页点击New Item，然后输入一个item name，选择Pipeline，最后点击OK。</p>

<p><img src="/images/img_for_ci/new.jpg" alt="创建item" /></p>

<p>创建完item之后，就会进入配置页面，我们在这里需要配置trigger方式，以及Pipeline脚本等。配置pipeline脚本有两种方式，一种是写在页面上，一种是写在源代码中。</p>

<p><img src="/images/img_for_ci/script.jpg" alt="配置item" /></p>

<p>配置完成后，点击Build Now，就可以开始build我们的项目了。</p>

<p><img src="/images/img_for_ci/build.jpg" alt="构建状态" /></p>

<p>如图是我们的构建结果，一列是一个stage，每个stage执行脚本中定义的操作。</p>

<h4>Pipeline说明</h4>

<p>上述Pipeline有如下的基本概念：</p>

<ul>
<li>Stage: 一个Pipeline可以划分为若干个Stage，每个Stage代表一组操作。注意，Stage是一个逻辑分组的概念，可以跨多个Node。</li>
<li>Node: 一个Node就是一个Jenkins节点，或者是Master，或者是Agent，是执行Step的具体运行期环境。</li>
<li>Step: Step是最基本的操作单元，小到创建一个目录，大到构建一个Docker镜像，由各类Jenkins Plugin提供。</li>
</ul>


<p>具体构成如下：</p>

<ul>
<li>Stage View: Pipeline的视觉展现，类似于上图。</li>
<li>Jenkinsfile: Pipeline的定义文件，由Stage，Node，Step组成，一般存放于代码库根目录下，如下所示。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">node</span> <span class="p">{</span>
</span><span class='line'>   <span class="nx">def</span> <span class="nx">mvnHome</span>
</span><span class='line'>   <span class="nx">stage</span><span class="p">(</span><span class="s1">&#39;Preparation&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for display purposes</span>
</span><span class='line'>      <span class="c1">// Get some code from a GitHub repository</span>
</span><span class='line'>      <span class="nx">git</span> <span class="s1">&#39;https://github.com/jglick/simple-maven-project-with-tests.git&#39;</span>
</span><span class='line'>      <span class="c1">// Get the Maven tool.</span>
</span><span class='line'>      <span class="c1">// ** NOTE: This &#39;M3&#39; Maven tool must be configured</span>
</span><span class='line'>      <span class="c1">// **       in the global configuration.           </span>
</span><span class='line'>      <span class="nx">mvnHome</span> <span class="o">=</span> <span class="nx">tool</span> <span class="s1">&#39;M3&#39;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="nx">stage</span><span class="p">(</span><span class="s1">&#39;Build&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Run the maven build</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnix</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>         <span class="nx">sh</span> <span class="s2">&quot;&#39;${mvnHome}/bin/mvn&#39; -Dmaven.test.failure.ignore clean package&quot;</span>
</span><span class='line'>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>         <span class="nx">bat</span><span class="p">(</span><span class="sr">/&quot;${mvnHome}\bin\mvn&quot; -Dmaven.test.failure.ignore clean package/</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="nx">stage</span><span class="p">(</span><span class="s1">&#39;Results&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">junit</span> <span class="s1">&#39;**/target/surefire-reports/TEST-*.xml&#39;</span>
</span><span class='line'>      <span class="nx">archive</span> <span class="s1">&#39;target/*.jar&#39;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Jenkins 2.x 默认支持三种类型的Pipeline有三种，普通Pipeline，Multibranch Pipeline和Organization Folders，后两种其实是批量创建一组普通Pipeline的快捷方式，分别对应于多分支的应用和多应用的大型组织。注意，要获取Organization Folders的支持需要额外安装Plugin。</p>

<p>至此我们已经介绍了Jenkins的安装以及Pipeline as Code的基本用法，更多关于Jenkins的操作请参见<a href="https://jenkins.io/doc/">官方文档</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/28/chi-xu-ji-cheng-er/">持续集成之我见（二）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-28T10:41:35+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:41 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>持续集成工具推荐</h2>

<p>前面的文章提到了一些关于持续集成的概念，以及持续集成工具应该具有的功能，和团队成员应该遵守的ci纪律，下面我讲介绍几种常用的持续集成的工具。</p>

<h3>Jenkins</h3>

<p><a href="https://jenkins.io/">Jenkins</a>是一个应用广泛的开源持续集成工具，它提供了数百个插件来支持项目的自动化编译、测试、部署等，使得开发人员可以从繁杂的集成中解脱出来，专注在更加重要的业务逻辑实现上。同时 Jenkins 能实时监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。Jenkins可以很好的支持各种语言（比如：java, c#, php等）的项目构建，也完全兼容ant、maven、gradle等多种第三方构建工具，同时跟svn、git能无缝集成，也支持直接与知名源代码托管网站，比如github、bitbucket直接集成。关于如何使用Jenkins，后续文章会做详细的介绍。</p>

<h3>Travis CI</h3>

<p><a href="https://travis-ci.org/">Travis CI</a>是一个可以与Github完美集成的开源持续集成工具，当用户登录到Travis CI之后，可以同步的从界面中看到该用户Github账号中的repo，用户可以方便的为这些repo中的代码创建ci。它不需要复杂的界面，允许你通过在源码里面增加一个名为<code>.travis.yml</code>的文件来对构建进行配置。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">language</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">ruby</span>
</span><span class='line'><span class="l-Scalar-Plain">rvm</span><span class="p-Indicator">:</span>
</span><span class='line'> <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">2.2</span>
</span><span class='line'> <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">jruby</span>
</span><span class='line'> <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">rbx-2</span>
</span></code></pre></td></tr></table></div></figure>


<p>上文中的配置文件告诉Travis CI这是一个Ruby项目，将会使用rake构建。接下来的rvm告诉Travis CI，这个项目的测试环境是Ruby 2.2，最新版本的JRuby和Rubinius。用户只需将这个配置文件提交到代码库中就可以触发Travis CI构建项目，并在构建页面来查看项目构建状态。</p>

<h3>Concourse</h3>

<p><a href="http://concourse.ci/">Concourse</a>是一个开源的持续集成工具，它使用yaml文件来配置pipeline，以及设置其他无需配置的安装。根据其开发团队的说法，它的主要优点是：</p>

<ul>
<li>为pipeline提供明确的、第一级的支持；</li>
<li>在容器中运行相互隔离的构建工作；</li>
<li>可避免使用雪花型构建服务器；</li>
<li>能够方便地访问日志；</li>
<li>概念简单。</li>
</ul>


<p>Concourse的最终目标是以尽可能少的变化部分提供一种具有表达性的系统。它设立了三种核心概念：任务、资源、作业。</p>

<ul>
<li>任务（Task）是执行的基本单元，表现为在一个全新启动的容器中所运行的脚本。容器已经经过了预处理，因此其中包含了一个输入与输出目录，任务脚本可在这些目录中运行。</li>
<li>资源（Resource）则表现为版本化资源的抽象位置，例如某个repo。资源也可用于对进入或退出某个管道的外部依赖进行建模，或是表示更抽象的概念，例如时间触发器。资源的变更可被检测、获取、以及发布。不同的资源类型（例如Git、AWS S3或触发器）可用于封装用于管道的各种样板代码，为Concourse的扩展提供了一个可适配的接口。</li>
<li>作业（Job）是由资源与任务构成的，通过构建计划实现。作业可由资源的变更所触发，也可以选择手动触发，以实现人工批准流程。</li>
</ul>


<p>一个作业计划的执行实例被称为一次构建（Build），Concourse中的构建是可重复使用的，因为其中的任务在新的容器中也将重新运行。因此，构建的工作线程不会受到之前运行结果的变更所影响。此外，如果某次构建失败了，也可以通过一个名为Fly的Concourse命令行工具在某个容器中再一次在本地运行，通过这种方式实现更快的开发周期。</p>

<h3>Go</h3>

<p><a href="https://www.go.cd/">Go</a>是ThoughtWorks开发的一款开源持续集成工具。它采用了Server-Agent模式，Server用来展示和配置pipeline的界面，并存放构建出来的Artifacts；Agent用来执行构建操作，一个Server可以和多个Agent建立连接，Agent支持多个主流的操作系统。</p>

<p><img src="/images/img_for_ci/go_cd.jpg" alt="Server Agent模式" /></p>

<p>每种工具的具体使用方法，请详见各自的文档。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/27/chi-xu-ji-cheng/">持续集成之我见（一）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-27T22:12:38+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:12 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>什么是持续集成</h2>

<p><a href="http://baike.baidu.com/view/5253255.html">持续集成（Continuous integration）</a>是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>

<h2>为什么要持续集成</h2>

<p>在我刚到上一个项目时，团队成员工作在下面一种工作模式中。项目代码在开发人员的本地，一个人负责一个或多个小项目。需求分析人员写好需求文档，然后和开发人员、测试人员一起开一个需求评审会，然后开发人员开始写代码，测试人员开始写测试文档。当开发完成需求后，手动的完成代码打包，然后手动部署到SIT环境供测试人员进行测试。部署完成后，测试人员就开始了疯狂的寻找bug之旅，将bug录入系统并交给开发去改，周而复始，完成上面的往复。直至此环境的测试工作完成，然后开发人员又去手动部署到UAT环境，依旧完成上次的循环，直至项目发布。在项目发布之前还会将代码拷贝给其他部门进行代码规范、安全等审查，在针对审查出来的问题进行改正，往往这个改动又会引入其他问题。</p>

<p>这种系统，采用传统的模式开发，在代码开发完成后才集成起来进行测试，很多在项目早期就存在的bug都是在完成开发工作之后才被发现，不利于定位问题，增加工作难度，而且每次部署都是手动的，有的环境甚至有几十台机器需要部署，单单打包部署这种重复劳动就使开发人员的工作苦不堪言。开发从来不写单元测试，甚至也不怎么认真进行自测，完成代码就交给测试去测，甚至还会发现将输入页面的用户名和密码的输入框写反了这种低级错误，而且项目一旦出现问题就是为什么测试人员没有测出来这个bug，我甚至遇到过因为项目出了线上bug而将测试人员开除的情况，这使得测试人员的工作也是压力山大。</p>

<p>在这种困境之下徘徊很久，项目组引入持续集成的概念，使用git作为版本控制工具，使用gradle作为构建工具，使用Jenkins搭建ci，增加自动化的代码编译、审查、单元测试、集成测试，以及自动化部署等。从艰难推行，到客服困难运行了一段时间之后，发现持续集成给项目带来了很多好处。</p>

<h3>减少重复过程</h3>

<p>在以前的工作模式中，代码的编译、审查、测试、打包、部署、反馈等工作，都是手动进行，费时费力，而且容易出错。通过自动化的持续集成可以将这些重复的动作都变成自动化的，无需太多人工干预，减少重复的过程，可以节省时间、费用和工作量，让人们的时间更多的投入到动脑筋的、更高价值的事情上。</p>

<h3>减少风险</h3>

<p>在一个项目中，最不可靠最容易出错的因素就是人，减少大量重复的人力工作就大大的降低了项目的风险。另外，一天中进行多次的集成，并做了相应的自动化测试，这样有利于检查缺陷，了解软件的健康状况，减少假定。利用持续集成，开发人员对源代码进行的小改动，会及时和其他的代码进行集成，一旦出现问题，项目成员马上就会被通知到，问题也会在第一时间被修复。</p>

<h3>任何时间、任何地点生成可部署的软件</h3>

<p>开发提交代码之后，只有构建成功，就会生成一个在任何时间可部署的软件产品，可恐怕是对用户来说最显而易见的好处。不采用持续集成的情况下，项目中的问题有可能到交付前的集成测试的时候才发现，有可能会导致延迟发布产品，而在急于修复这些缺陷的时候又有可能引入新的缺陷，最终可能导致项目失败。</p>

<h3>增强项目的可见性</h3>

<p>持续集成可以带来两点积极效果：</p>

<ul>
<li>有效决策：持续集成系统为项目构建状态和品质指标提供了及时的信息，有些持续集成系统可以报告功能完成度和缺陷率。</li>
<li>注意到趋势：由于经常集成，我们可以看到一些趋势，如构建成功或失败、总体品质以及其它的项目信息。</li>
</ul>


<p>如果没有真实或最新的数据提供支持，项目就会遇到麻烦，每个人都会提出他最好的猜测。通常，项目成员通过手工收集这些信息，增加了负担，也很耗时。</p>

<h3>建立团队对开发产品的信心</h3>

<p>采用持续集成，团队成员可以清楚的知道每一次构建的结果，看到自己对软件的改动造成了哪些影响，结果怎么样，这种即时、可视化的信息可以增加了团队的信心。</p>

<h2>如何做到持续集成</h2>

<p>根据上文的描述，我们使用的持续集成工具需要做到下面几个功能：</p>

<ul>
<li>自动构建：构建工作需要在提交代码之后自动执行，要求无人值守，如果人工来操作，那么持续集成就毫无魅力。</li>
<li>发现版本库的变更：通过轮询或者定时，触发持续集成工具发现版本库的变更。</li>
<li>反馈机制：在出现问题时，能及时的把问题反馈给正确的人（提交者、测试者、管理者）</li>
<li>回滚：在出现问题后，拥有回滚到可交付的能力。</li>
<li>纯净的构建环境：每一次都应该把之前的环境删除干净，让每一次构建都是一个新的构建。</li>
<li>完善的集成功能：代码的测试，审查，部署都应该做到完善。如果单纯的利用它做持续的编译，那就是大材小用了。</li>
</ul>


<p>使用持续集成工具搭建构建流水线仅仅是第一步，全组成员依照默认的纪律使用ci才能使其最大化发生作用。一个开始准备要提交新修改的代码时，应该遵循如下步骤：</p>

<ol>
<li>查看ci是否正在构建。如果有的话，你要等它运行完。如果构建失败了，你要与团队成员一起将其修复。</li>
<li>一旦构建完成且测试全部通过，就从版本控制库中更新最新的代码到本地。</li>
<li>在本地执行构建脚本，运行测试，以确保代码在本地可以正常工作。</li>
<li>如果本地构建成功，就将代码提交到远端代码库。</li>
<li>等待这次提交的构建结果。</li>
<li>如果构建失败，就应该停下来手头的工作，修复构建问题，然后转到步骤3。</li>
<li>如果构建成功，你就可以happy的进行接下来的工作了。</li>
</ol>


<p>至此，我们对持续集成已经有了一个简单的认识，在接下来的文章中，我将会介绍一些持续集成工具，以及如何使用这些工具。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/29/nginx-sinatra/">一个简单的负载均衡系统</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-29T17:19:11+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:19 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://baike.baidu.com/link?url=IJriLUPAnM_nNxQw8eVoqfU4R9Tc8sl28d5QcZ7sOYp9jcNAA-HGq7RENalBfm-a">负载均衡</a>是由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。通过某种负载分担技术，将外部发送来的请求分配到对称结构中的某一台服务器上，而接受到请求的服务器独立的回应客户的请求。负载均衡能够平均分配客户请求到服务器阵列，以提高相应速度，解决大量并发访问服务器问题。实现网络的负载均衡有很多方法，例如使用Nginx, LVS, HAProxy，f5等。本文将介绍如何使用Nginx配置一个简单的负载均衡系统。</p>

<p><a href="http://nginx.org/">Nginx</a>是一款轻量级的Web服务器/反向代理服务器以及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占有内存少，并发能力强。本文会将Nginx封装在一个Docker Image中，将其作为Web服务器，分发来自用户的请求到不同的App服务器中，其中的App服务器是也是一个Docker Image封装的简单的Sinatra应用。然后将几个Image运行在一个Ubuntu机器上，模拟一个Web服务器和多台App服务器的环境，当然你的机器上首先需要<a href="https://docs.docker.com/installation/ubuntulinux/">安装Docker</a>。</p>

<p>下面先来看看怎么实现这两个Docker Image。</p>

<h2>创建Sinatra App服务</h2>

<h3>Docker Image实现代码介绍</h3>

<p><a href="http://jiamaoweilie.github.io/blog/2015/07/12/docker/">上篇文章</a>中介绍了如何使用Docker构建开发环境，这里不在赘述，直接看看它的Dockerfile文件的内容。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM ubuntu:14.04
</span><span class='line'>
</span><span class='line'>MAINTAINER wei 20150629
</span><span class='line'>
</span><span class='line'>RUN apt-get update
</span><span class='line'>RUN apt-get install -y build-essential wget git
</span><span class='line'>RUN apt-get install -y zlib1g-dev libssl-dev libreadline-dev libyaml-dev libxml2-dev libxslt-dev libmysqlclient-dev
</span><span class='line'>RUN apt-get clean
</span><span class='line'>
</span><span class='line'>RUN wget http://cache.ruby-lang.org/pub/ruby/2.2/ruby-2.2.2.tar.gz
</span><span class='line'>RUN tar xvf ruby-2.2.2.tar.gz
</span><span class='line'>RUN cd /ruby-2.2.2; ./configure; make install
</span><span class='line'>
</span><span class='line'>RUN gem update --system
</span><span class='line'>
</span><span class='line'>RUN gem install bundler
</span><span class='line'>
</span><span class='line'>ADD app.rb /app.rb
</span><span class='line'>
</span><span class='line'>ADD Gemfile /Gemfile
</span><span class='line'>
</span><span class='line'>ADD config.ru /config.ru
</span><span class='line'>
</span><span class='line'>RUN bundle install
</span><span class='line'>
</span><span class='line'>EXPOSE 9292
</span><span class='line'>
</span><span class='line'>CMD rackup --host 0.0.0.0</span></code></pre></td></tr></table></div></figure>


<p>从上述代码可以看出，该Image使用ubuntu:14.04作为基础，然后使用apt-get安装一些工具，再安装了ruby环境，并将app.rb、Gemfile、和config.ru文件拷贝到Image中，然后执行<code>bundle install</code>安装应用所使用的gem依赖,再将9292端口暴露出来，最后使用rackup命令启动该应用。</p>

<h3>应用实现代码介绍</h3>

<p>该实例的<code>app.rb</code>实现了一个特别简单的Sinatra应用，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require 'sinatra'
</span><span class='line'>
</span><span class='line'>class App &lt; Sinatra::Base
</span><span class='line'>  get '/' do
</span><span class='line'>    "Hello World!"
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p><code>Gemfile</code>文件中定义了该应用的gem依赖：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source 'https://rubygems.org'
</span><span class='line'>
</span><span class='line'>gem 'sinatra'</span></code></pre></td></tr></table></div></figure>


<p><code>config.ru</code>文件为使用Rack的gem中提供的工具rackup工具为该应用编写了一个启动项，具体内容为下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require File.dirname(__FILE__) + '/app'
</span><span class='line'>
</span><span class='line'>run App</span></code></pre></td></tr></table></div></figure>


<p>完成上面代码之后，像Dockerfile文件中那样，执行<code>bundle install</code>安装依赖，然后执行<code>rackup</code>启动程序，访问<code>localhost://9292</code>就会显示<strong>Hello World!</strong></p>

<p>完成代码的编写之后，运行<code>docker build</code>命令来build我们的Image：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker build -t docker-sinatra .</span></code></pre></td></tr></table></div></figure>


<p>执行完该命令之后就生成了一个名为docker-sinatra的docker image，我们可以通过<code>docker images</code>命令查看当前机器上所有的docker image。</p>

<p>然后执行如下命令来生成一个Container来运行该image：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run -d -p 8080:9292 docker-sinatra</span></code></pre></td></tr></table></div></figure>


<p>该命令运行名为docker-siatra的Image，并将Container中的9292端口映射到Ubuntu的8080端口，这样我们访问<code>localhost://8080</code>就可以看到我们想要的<strong>Hello World!</strong>了。</p>

<p>同样，如果我们想要8081端口也运行着这个app服务，只需执行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -d -p 8081:9292 docker-sinatra</span></code></pre></td></tr></table></div></figure>


<p>至此，我们已经实现了两个简单的Sinatra App服务，下面就来看看如何使用Nginx来分配用户的访问请求。</p>

<h2>使用Nginx实现负载均衡</h2>

<h3>创建Nginx Docker Image</h3>

<p>具体的Dockerfile文件如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM ubuntu:14.04
</span><span class='line'>
</span><span class='line'>MAINTAINER wei 20150629
</span><span class='line'>
</span><span class='line'>RUN apt-get update && \
</span><span class='line'>    apt-get install -y nginx && \
</span><span class='line'>    rm -rf /var/lib/apt/lists/* && \
</span><span class='line'>    echo "\ndaemon off;" &gt;&gt; /etc/nginx/nginx.conf && \
</span><span class='line'>    chown -R www-data:www-data /var/lib/nginx
</span><span class='line'>
</span><span class='line'>ADD run.sh /run.sh
</span><span class='line'>
</span><span class='line'>RUN chmod 755 /*.sh
</span><span class='line'>
</span><span class='line'>VOLUME ["/etc/nginx/sites-enabled", "/etc/nginx/certs", "/etc/nginx/conf.d", "/var/log/nginx", "/var/www/html"]
</span><span class='line'>
</span><span class='line'>WORKDIR /etc/nginx
</span><span class='line'>
</span><span class='line'>CMD ["/run.sh"]
</span><span class='line'>
</span><span class='line'>EXPOSE 80 </span></code></pre></td></tr></table></div></figure>


<p>从上述代码可知，该Image安装了nginx，并配置了一些共享目录，最后run了一个脚本来启动nginx服务。</p>

<p>其中<code>run.sh</code>的内容为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'># start nginx service
</span><span class='line'>/usr/sbin/nginx</span></code></pre></td></tr></table></div></figure>


<p>以上部分我们就完成了Nginx的Docker Image的基本编写，这时候<code>build</code>这个image：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker build -t docker-nginx .</span></code></pre></td></tr></table></div></figure>


<p>然后run:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -d -p 80:80 docker-nginx</span></code></pre></td></tr></table></div></figure>


<p>访问<code>localhost</code>，可以看到如下页面：</p>

<p><img src="/images/img_for_LB/nginx.png" alt="" /></p>

<p>这说明Nginx服务已经启动，下面我们就来更改它的配置文件使之可以作为Web服务器，分配用户访问请求到我们上面已经启动的两个app服务器上。</p>

<h3>Nginx配置文件</h3>

<p>Nginx的配置文件为<code>nginx.conf</code>，一般的存储路径为<code>/etc/nginx/nginx.conf</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#运行用户
</span><span class='line'>user www-data;
</span><span class='line'>#启动进程,通常设置成和cpu的数量相等
</span><span class='line'>worker_processes 1;
</span><span class='line'>#全局错误日志及PID文件
</span><span class='line'>error_log  /var/log/nginx/error.log;
</span><span class='line'>pid /run/nginx.pid;
</span><span class='line'>
</span><span class='line'>#工作模式及连接数上限
</span><span class='line'>events {
</span><span class='line'>  worker_connections 768;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>#设定http服务器，利用它的反向代理功能提供负载均衡支持
</span><span class='line'>http {
</span><span class='line'>  
</span><span class='line'>  #设定mime类型,类型由mime.type文件定义
</span><span class='line'>  include /etc/nginx/mime.types;
</span><span class='line'>  default_type  application/octet-stream;
</span><span class='line'> 
</span><span class='line'>  #sendfile指令指定nginx是否调用sendfile函数（zero copy 方式来输出文件，对于普通应用必须设为on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.
</span><span class='line'>  sendfile        on;
</span><span class='line'>  keepalive_timeout  65;
</span><span class='line'>  
</span><span class='line'>  #设定负载均衡的服务器列表
</span><span class='line'>  upstream allserver {
</span><span class='line'>    server 192.168.59.104:8080;
</span><span class='line'>    server 192.168.59.104:8081;
</span><span class='line'>  }
</span><span class='line'>  server {
</span><span class='line'>    #侦听80端口
</span><span class='line'>    listen       80;
</span><span class='line'>    #定义使用localhist访问
</span><span class='line'>    server_name  localhost;
</span><span class='line'>    #默认请求
</span><span class='line'>    location / {
</span><span class='line'>      proxy_pass http://allserver;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>daemon off;</span></code></pre></td></tr></table></div></figure>


<p>上面代码展示了一个基本的Nginx配置文件，和关于该配置文件的简单介绍。其中，upstream节指定了运行在ip为192.168.59.104的机器上8080端口和8081端口的两个网络程序（就是我们上面起的两个sinatra应用）。server节中指定启动一个nginx进程，监听80端口，并将用户的访问全部转发到upstream中的两个程序上。</p>

<p>完成Nginx配置文件的更改之后，需要reload配置文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/usr/sbin/nginx -s reload</span></code></pre></td></tr></table></div></figure>


<p>这样，我们的配置文件就可以生效了，当用户访问<code>http://localhost</code>就可以看到页面显示的<strong>Hello World!</strong>了。而且，只要这两个程序中的一个还在运行，用户就可以正常的访问。</p>

<p>至此，我们就是用Nginx实现了一个简单的负载均衡系统，该实例中的详细代码，可以参见<a href="https://github.com/jiamaoweilie">我的github</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/12/docker/">使用Docker构建工作环境</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-12T23:38:26+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:38 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Docker简介</h3>

<p><a href="https://www.docker.com/">Docker</a>是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现。项目后来加入了Linux基金会，遵从了Apache 2.0协议，项目代码在GitHub上进行维护。</p>

<p>Docker自开源后受到广泛的关注和讨论，以至于 dotCloud公司后来都改名为 DockerInc。Redhat已经在其RHEL6.5中集中支持Docker Google也在其 PaaS产品中广泛应用。</p>

<p>Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker的基础是 Linux 容器（LXC）等技术。</p>

<p>在LXC的基础上，Docker进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作Docker的容器就像操作一个快速轻量级的虚拟机一样简单。</p>

<h3>基本概念</h3>

<p>Docker包括三个基本概念：</p>

<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>


<h4>Docker Image</h4>

<p>Image是一个只读的模板，可以用来创建Docker Container。一个镜像可以包含一个完整的ubuntu操作系统环境，里面仅安装了Nginx或用户需要的其它应用程序。Docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p>

<h4>Docker Container</h4>

<p>Docker利用container来运行应用。它就是从image创建的运行实例，可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>

<h4>Docker Repository</h4>

<p>Repository是集中存放镜像文件的地方，分为public和private两种形式。</p>

<p>最大的公开repository是<a href="https://hub.docker.com/">Docker Hub</a>，存放了数量庞大的镜像供用户下载。国内的公开repository包括<a href="http://www.dockerpool.com/">Docker Pool</a>等，可以提供大陆用户更稳定快速的访问。</p>

<p>当然，用户也可以在本地网络内创建一个私有repository。用户创建了自己的image之后就可以使用<code>push</code>命令将它上传到公有或者私有repository，这样下次在另外一台机器上使用这个image时候，只需要从仓库上 <code>pull</code>下来就可以。</p>

<h3>获取和使用Image</h3>

<p>获取镜像的方式有很多种，用户可以直接从repository上<code>pull</code>已有的image，也可以自己创造一个image。这里着重介绍如何创造一个Docker image。</p>

<p>使用<code>docker build</code>创建一个新的镜像，需要首先创建一个Dokcerfile，其中包含一些创建镜像的指令。Dockerfile中的每一条指令创建镜像的一层。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># This is a comment
</span><span class='line'>FROM ubuntu:14.04
</span><span class='line'>
</span><span class='line'>MAINTAINER wei 20150629
</span><span class='line'>
</span><span class='line'>RUN apt-get update && \
</span><span class='line'>    apt-get install -y nginx && \
</span><span class='line'>    rm -rf /var/lib/apt/lists/* && \
</span><span class='line'>    echo "\ndaemon off;" &gt;&gt; /etc/nginx/nginx.conf && \
</span><span class='line'>    chown -R www-data:www-data /var/lib/nginx
</span><span class='line'>
</span><span class='line'>VOLUME ["/etc/nginx/sites-enabled", "/etc/nginx/certs", "/etc/nginx/conf.d", "/var/log/nginx", "/var/www/html"]
</span><span class='line'>
</span><span class='line'>WORKDIR /etc/nginx
</span><span class='line'>
</span><span class='line'>CMD /usr/sbin/nginx
</span><span class='line'>
</span><span class='line'>EXPOSE 80 </span></code></pre></td></tr></table></div></figure>


<p>Dockerfile 基本的语法是:</p>

<ul>
<li>使用#来注释</li>
<li>FROM 指令告诉 Docker 使用哪个镜像作为基础</li>
<li>接着是维护者的信息</li>
<li>RUN开头的指令会在创建中运行，比如安装一个软件包，在这里使用<code>apt-get
</code>安装了nginx</li>
<li>ADD 命令复制本地文件到镜像</li>
<li>VOLUME 命令创建一个挂载点用于共享目录</li>
<li>EXPOSE 命令来向外部开放端口</li>
<li>WORKDIR 命令设置当前工作路径</li>
<li>CMD 命令来描述容器启动后运行的程序，比如上例用来启动nginx</li>
</ul>


<p>完成Dockerfile之后，使用<code>docker build</code>命令来生成镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker build -t docker-nginx .</span></code></pre></td></tr></table></div></figure>


<p>这条命令表示，<code>build</code>当前路径下的Dockerfile， <code>-t</code>标记来添加tag，指定新的image的信息。</p>

<p><img src="/images/img_for_docker/build.png" alt="" /></p>

<p>从上图中可以看到build进程的执行过程。首先，它会上传Dockerfile的内容，因为所有的操作都依据这个Dockerfile进行。然后，逐条执行Dockerfile里面定义的任务。每一步都创建了一个新的容器，在容器中执行指令并提交修改。当所有的指令都执行完毕之后，返回了最终的镜像 id。所有的中间步骤所产生的容器都被删除和清理了。</p>

<p>使用<code>docker images</code>可以查看当前的所有image，或者对image进行其他操作，比如删除：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker rmi docker-nginx</span></code></pre></td></tr></table></div></figure>


<p>成功创建docker image之后，就是创建执行它的容器了。</p>

<h3>Container的使用</h3>

<p>启动container有两种方式，一种是基于image新建一个容器并启动，另外一个是将在终止状态（stopped）的container重新启动。因为Docker的container特别轻量级，用户可以随时删除和新创建容器。</p>

<p>创建并使用container的主要命令是<code>docker run</code>, 例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run -d -p 80:80 docker-nginx</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/img_for_docker/run.png" alt="" />
<code>run</code>命令执行该image，生成一个容器，<code>-d</code>表示后台运行，并打印出该image的id。-p 80:80，表示将80端口暴露出来。</p>

<p>我们可以使用<code>exec</code>命令进入执行该image的容器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker exec -it docker-nginx bash</span></code></pre></td></tr></table></div></figure>


<p>使用<code>docker pa -a</code>查看当前所有container的状态：</p>

<p><img src="/images/img_for_docker/con.png" alt="" /></p>

<p>或者使用<code>docker stop</code>来停止一个容器，使用<code>docker rm</code>来删除一个容器。</p>

<p>另外，我们还可以将自己创造的docker image push到远程或者本地的repository中，以方便后续使用。这样我们就可以利用docker，方便的定制自己需要的工作环境，并且能够轻松的移植到任何一台机器上。更多关于docker的操作请参见其<a href="http://docs.docker.com/mac/started/">官方文档</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/19/graphite/">安装和配置Graphite</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-19T23:20:29+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:20 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Graphite简介</h2>

<p><a href="https://graphite.readthedocs.org/en/latest/index.html">Graphite</a>是一个Python编写的企业级开源监控工具，采用<a href="https://www.djangoproject.com/">django框架</a>，用来收集服务器所有的即时状态，用户请求信息，<a href="http://memcached.org/">Memcached</a>命中率,<a href="https://www.rabbitmq.com/">RabbitMQ</a>消息服务器的状态，操作系统的负载状态。Graphite服务器大约每分钟需要有4800次的跟新操作，它采用简单的文本协议和绘图功能，可以方便的使用在任何操作系统上。Graphite 自己本身并不收集具体的数据，这些数据收集的具体工作通常由第三方工具或插件完成（如 Ganglia, collectd, statsd, Collectl 等).</p>

<p>简单来说，Graphite主要做两件事情：</p>

<ol>
<li>实时监控第三方工具传来的数据</li>
<li>根据数据绘制图形</li>
</ol>


<p>Graphite包含3个组件，carbon，whisper，graphite webapp其中：</p>

<ol>
<li>carbon - 用于监控数据的 Twisted 守护进程</li>
<li>whisper - 用于存放和操作数据的库</li>
<li>graphite webapp - 用于绘制图形的Django webapp</li>
</ol>


<h2>在ubuntu上安装Graphite</h2>

<p>需要安装一下必要的软件包：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install apache2 libapache2-mod-wsgi python-django python-twisted python-cairo python-pip python-django-tagging</span></code></pre></td></tr></table></div></figure>


<p>然后我们使用pip安装Graphite的三个组件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo pip install whisper
</span><span class='line'>sudo pip install carbon
</span><span class='line'>sudo pip install graphite-web</span></code></pre></td></tr></table></div></figure>


<p>这样的方法会将它们安装在默认路径<code>/opt/graphite</code>下，其<a href="https://graphite.readthedocs.org/en/latest/install.html">文档</a>中还提供各种其他安装方法。</p>

<h2>初始化配置</h2>

<h3>local_setting.py</h3>

<p><code>local_settings.py</code>是Graphite-web的基本配置文件，它位于<code>graphite</code>文件下的<code>/webapp/graphite</code>下，在默认安装方式下改文件的路径是<code>/opt/graphite/webapp/graphite/local_settings.py</code>.</p>

<p>我们可以直接拷贝实例配置文件，再根据自身需求做相应修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /opt/graphite/webapp/graphite/
</span><span class='line'>sudo cp local_settings.py.example local_settings.py</span></code></pre></td></tr></table></div></figure>


<p>基本的配置信息有诸如: <code>TIME_ZONE</code>，<code>DOCUMENTATION_URL</code>, <code>LOG_RENDERING_PERFORMANCE</code>等，可以根据自己需求进行更改。</p>

<p>此处，我们做如下修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>...
</span><span class='line'>TIME_ZONE = 'Asia/Shanghai'
</span><span class='line'>...
</span><span class='line'>DEBUG=True
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p><code>local_setting.py</code>里面还会包含一些关于系统文件路径的配置，可以配置一下Graphite文件系统的路径。例如<code>GRAPHITE_ROOT</code>（graphite安装路径，默认为<code>/opt/graphite</code>）,<code>CONF_DIR</code>(graphite配置文件的路径，默认为<code>GRAPHITE_ROOT/conf</code>)。</p>

<h3>配置web服务器apache</h3>

<p>修改apache配置，需要增加一个<a href="https://httpd.apache.org/docs/2.2/vhosts/">vhost</a>。或者可以下载一个配置文件覆盖<code>/etc/apache2/sites-available/</code>目录下的<code>default</code>文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget http://launchpad.net/graphite/0.9/0.9.9/+download/graphite-web-0.9.9.tar.gz
</span><span class='line'>tar -zxvf graphite-web-0.9.9.tar.gz
</span><span class='line'>
</span><span class='line'>cd graphite-web-0.9.9
</span><span class='line'>
</span><span class='line'>sudo cp examples/example-graphite-vhost.conf /etc/apache2/sites-available/default</span></code></pre></td></tr></table></div></figure>


<p>同时需要修改default文件下<code>WSGIScriptAlias</code>的路径：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo vi /etc/apache2/sites-available/default
</span><span class='line'>
</span><span class='line'>...
</span><span class='line'>WSGISocketPrefix /var/run/apache2/wsgi
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>配置完成之后，需要reload。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo /etc/init.d/apache2 reload</span></code></pre></td></tr></table></div></figure>


<h3>配置数据库</h3>

<p>初始化Graphite需要的数据库，需要更改storage的权限：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /opt/graphite/webapp/graphite/
</span><span class='line'>
</span><span class='line'>sudo python manage.py syncdb
</span><span class='line'>sudo chown -R www-data:www-data /opt/graphite/storage/</span></code></pre></td></tr></table></div></figure>


<p>然后重启apache：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo /etc/init.d/apache2 restart</span></code></pre></td></tr></table></div></figure>


<h3>配置carbon</h3>

<p>carbon的配置文件位于<code>/opt/graphite/conf</code>下，我们可以通过简单的复制<code>example</code>目录中的文件作为配置文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /opt/graphite/conf/
</span><span class='line'>
</span><span class='line'>sudo cp carbon.conf.example carbon.conf
</span><span class='line'>sudo cp storage-schemas.conf.example storage-schemas.conf
</span><span class='line'>sudo cp graphite.wsgi.example graphite.wsgi</span></code></pre></td></tr></table></div></figure>


<p>配置完成之后，启动carbon，就可以在浏览器中看到Graphite的界面。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo /opt/graphite/bin/carbon-cache.py start</span></code></pre></td></tr></table></div></figure>


<p>更多关于Graphite的配置信息，可以参见<a href="https://graphite.readthedocs.org/en/latest/config-local-settings.html#database-configuration">相关文档</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/22/flyway/">使用Flyway管理数据库</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-22T22:44:14+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>10:44 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>以前几乎没有自己好好弄过数据库相关的东西，除了照猫画虎的改过几个表结构，几乎还是一窍不通。今天在组里的workshop上需要从零开始搭建各种环境，跟着组里人学了学使用Flyway来管理数据库。据说它是一个很高大上的数据库管理工具，不过具体高大上在哪里我这只菜鸟还不是很清楚，先来梳理一下它在我们workshop中的用法吧。</p>

<h2><strong>讨厌的配置</strong></h2>

<p>首先当然是进行一堆乱七八糟的配置，是我最讨厌的东西，可是没有办法，必经之路。我们的工程使用maven作为构建工具，所以需要在pom.xml文件中加入flywaydb的插件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>    <span class="nt">&lt;groupId&gt;</span>org.flywaydb<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>flyway-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>3.1<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>        ....
</span><span class='line'>    <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'><span class="nt">&lt;/plugin&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码描述了该插件的名字，版本号，以及一些flyway的配置。配置flyway的方式有很多种，我们可以像下面这样pom.xml里面配置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>    ...
</span><span class='line'>    <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>        <span class="nt">&lt;user&gt;</span>myUser<span class="nt">&lt;/user&gt;</span>
</span><span class='line'>        <span class="nt">&lt;password&gt;</span>mySecretPwd<span class="nt">&lt;/password&gt;</span>
</span><span class='line'>        <span class="nt">&lt;schemas&gt;</span>
</span><span class='line'>            <span class="nt">&lt;schema&gt;</span>schema1<span class="nt">&lt;/schema&gt;</span>
</span><span class='line'>            <span class="nt">&lt;schema&gt;</span>schema2<span class="nt">&lt;/schema&gt;</span>
</span><span class='line'>            <span class="nt">&lt;schema&gt;</span>schema3<span class="nt">&lt;/schema&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/schemas&gt;</span>
</span><span class='line'>        <span class="nt">&lt;placeholders&gt;</span>
</span><span class='line'>            <span class="nt">&lt;keyABC&gt;</span>valueXYZ<span class="nt">&lt;/keyABC&gt;</span>
</span><span class='line'>            <span class="nt">&lt;otherplaceholder&gt;</span>value123<span class="nt">&lt;/otherplaceholder&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/placeholders&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'><span class="nt">&lt;/plugin&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>也可以通过一个外部的配置文件来配置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>flyway.user=myUser
</span><span class='line'>flyway.password=mySecretPwd
</span><span class='line'>flyway.schemas=schema1,schema2,schema3
</span><span class='line'>flyway.placeholders.keyABC=valueXYZ
</span><span class='line'>flyway.placeholders.otherplaceholder=value123
</span></code></pre></td></tr></table></div></figure>


<p>然后执行mvn时通过指定参数<code>flyway.configFile</code>的值来指定配置文件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>mvn -Dflyway.configFile=myConfig.properties
</span></code></pre></td></tr></table></div></figure>


<p>默认的<code>flyway.properties</code>文件和pom.xml在相同的路径下。</p>

<p>另外还可以通过其他方式来指定flyway的配置参数，具体信息可以参加其与maven集成的<a href="http://flywaydb.org/documentation/maven/">相关文档</a>。</p>

<p>我们的工程中使用外部配置文件的方式进行配置，目前的配置文件如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>flyway.user=wjia
</span><span class='line'>flyway.password=
</span><span class='line'>flyway.driver=org.postgresql.Driver
</span><span class='line'>flyway.url=jdbc:postgresql://localhost:5432/wjia
</span><span class='line'>flyway.locations=classpath:db/migration
</span><span class='line'>flyway.sqlMigrationPrefix=V
</span><span class='line'>flyway.sqlMigrationSeparator=__
</span><span class='line'>flyway.sqlMigrationSuffix&gt;=.sql
</span><span class='line'>flyway.encoding=ISO-8859-1
</span><span class='line'>#flyway.baselineVersion=2
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，文件中指定了user，password，driver，url等用来连接数据库的信息。其中<code>flyway.locations</code>指定了sql文件的位置，<code>flyway.sqlMigrationPrefix</code>,
<code>flyway.sqlMigrationSeparator</code>,<code>flyway.sqlMigrationSuffix</code>共同指定了sql文件的命名方式，我们指定的命名方式是以V开头，__作为间隔符，.sql结尾。flyway有一些默认的命名的命名方式，如果不符合规定会造成操作的失败。</p>

<h2><strong>建sql吧</strong></h2>

<p>讨厌的配置完成之后，当然是开始建立数据库迁移任务了，依照上面配置文件中指定的文件路径和命名规则，我们在classpath（resources目录）下的db.migration目录中定义sql文件。例如，我们可以简单的建立一张数据表，然后在表中添加几条记录。</p>

<p>这样resources里面的工程目录就是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>└──resources
</span><span class='line'>  └──db.migration
</span><span class='line'>      └──V1__Create_guest_table.sql
</span><span class='line'>      └──V2__Add_guest.sql
</span></code></pre></td></tr></table></div></figure>


<p>在classpath下的db.migration目录下有两个简单的sql文件。文件内容分别如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>create table Guest (
</span><span class='line'>  id integer constraint pk PRIMARY KEY,
</span><span class='line'>  name varchar(40) not null,
</span><span class='line'>  signingDate date
</span><span class='line'>);
</span><span class='line'>create SEQUENCE guest_id_generator START 10000;
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>insert into Guest (ID, NAME,signingDate) values (1, &#39;Axel&#39;, &#39;2015-1-19&#39;);
</span><span class='line'>insert into Guest (ID, NAME,signingDate) values (2, &#39;Mr. Foo&#39;,&#39;2015-1-19&#39;);
</span><span class='line'>insert into Guest (ID, NAME,signingDate) values (3, &#39;Ms. Bar&#39;,&#39;2015-1-19&#39;);
</span></code></pre></td></tr></table></div></figure>


<p>至此我们就有了flyway的配置文件和数据库迁移任务文件，下面就到了flyway发挥作用的时候，看它如何帮助我们来管理数据库吧。</p>

<h2><strong>看flyway如何管理数据库</strong></h2>

<h4><strong>Migrate</strong></h4>

<p>flyway的最重要的功能当然是完成数据库迁移了，使用<code>mvn flyway:migrate</code>命令就可以方便的帮助我们执行<code>flyway.locations</code>目录中定义的migration任务。由于我们的使用了外部的flyway配置文件，因此在执行migration任务时需要加上参数<code>flyway.properties</code>来指定配置文件的位置。所以，在我们的工程中需要执行的任务为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>mvn flyway:migrate -Dflyway.configFile=localPath/flyway.properties
</span></code></pre></td></tr></table></div></figure>


<p>
其中<code>localPath/</code>为<code>flyway.properties</code>文件在本地的路径。执行完该任务后,就生成了我们需要的guest表，并生成了三条数据。查询数据库，可以得到以下表结构和数据：</p>

<p><img src="/images/img_for_flyway/table.jpg" alt="" /></p>

<h4><strong>Clean</strong></h4>

<p>如果我们想初始化数据库，删除所有的表和数据，那么只需要执行命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>mvn flyway:clean
</span></code></pre></td></tr></table></div></figure>


<h4><strong>Info</strong></h4>

<p>如果我们想知道所有migration的详细信息，可以通过执行下面命令来打印信息：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>mvn flyway:info
</span></code></pre></td></tr></table></div></figure>


<p>执行之后，Terminal中会打印出所有migration的详细信息，其中包括版本号，描述，执行时间，以及状态，具体信息如下图所示：</p>

<p><img src="/images/img_for_flyway/info.jpg" alt="" /></p>

<h4><strong>更多命令</strong></h4>

<p>flyway还提供了更多命令来帮助我们管理数据库。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>mvn flyway:validate
</span></code></pre></td></tr></table></div></figure>


<p>用来validate已经执行的migration任务。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>mvn flyway:baseline
</span></code></pre></td></tr></table></div></figure>


<p>用来回滚数据库到一个配置文件中设定好的baseline。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>mvn flyway:repair
</span></code></pre></td></tr></table></div></figure>


<p>用来删除执行失败的migration任务。</p>

<p>更多关于flyway的详细用法，请参见其<a href="http://flywaydb.org/documentation/">官方文档</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/07/mockjing-tai-fang-fa/">如何Mock静态方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-07T21:06:40+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:06 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近为客户一堆没有单元测试的代码补测试时，遇到了一堆奇葩的问题，其中一个是被测函数需要调用另外一个类中的静态方法。今天看几个同事讨论说这种写法不好，但是whatever，谁又能完全在理想状态下生存，现有的系统就是这样，测试总得写的吧。</p>

<p>那么我们的解决方法就是使用PowerMock将这些静态方面mock掉。怎么做的呢，通过下面的小例子说明一下。</p>

<p>假如我们有这样一个类EmployeeService需要测试：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeService</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getEmployeeCount</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Employee</span><span class="o">.</span><span class="na">count</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，这个类中有一个函数<code>getEmployeeCount()</code>，它里面调用了类<code>Employee</code>中的<code>count()</code>函数。需要测试的类是<code>EmployeeService</code>，那么自然不应该调用真实的类<code>Employee</code>。如何mock该类呢，我们可以使用PowerMock。</p>

<p>测试的实现代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@RunWith</span><span class="o">(</span><span class="n">PowerMockRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="nd">@PrepareForTest</span><span class="o">(</span><span class="n">Employee</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceTest</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>   <span class="nd">@Test</span>
</span><span class='line'>   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">shouldReturnTheCountOfEmployeesUsingTheDomainClass</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">PowerMockito</span><span class="o">.</span><span class="na">mockStatic</span><span class="o">(</span><span class="n">Employee</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>      <span class="n">PowerMockito</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">Employee</span><span class="o">.</span><span class="na">count</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="mi">900</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">EmployeeService</span> <span class="n">employeeService</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">EmployeeService</span><span class="o">();</span>
</span><span class='line'>      <span class="n">assertEquals</span><span class="o">(</span><span class="mi">900</span><span class="o">,</span><span class="n">employeeService</span><span class="o">.</span><span class="na">getEmployeeCount</span><span class="o">());</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，测试代码的顶部使用了两个annotation（<code>@RunWith</code>和<code>@PrepareForTest</code>），在测试实现中使用了<code>PowerMockito</code>。其中<code>@RunWith(PowerMockRunner.class)</code>告诉JUnit使用PowerMockRunner执行该测试。<code>@PrepareForTest(Employee.class)</code>告诉PowerMock类<code>Employee</code>是测试中需要用到的类。当我们需要mock一个final类，或需要mock的类中有final、static、private方法时，需要用到<code>@PrepareForTest</code>。<code>PowerMockito.mockStatic(Employee.class)</code>告诉PowerMock我们需要mock类Employee中所有的静态方法。<code>PowerMockito.when(Employee.count()).thenReturn(900)</code>，很显然，这句话就是告诉PowerMock当执行<code>Employee.count()</code>时，返回900。很显然，我们需要assert的是<code>employeeService.getEmployeeCount()</code>的返回值是不是等于900。至此，该测试就算完成了。</p>

<p>但是，如果<code>EmployeeService</code>中有一个函数需要调用一个返回值为void的静态方面，我们又该如何处理。比如，<code>EmployeeService</code>s中有这样一个方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">giveIncrementToAllEmployeesOf</span><span class="o">(</span><span class="n">intpercentage</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>   <span class="k">try</span><span class="o">{</span>
</span><span class='line'>      <span class="n">Employee</span><span class="o">.</span><span class="na">giveIncrementOf</span><span class="o">(</span><span class="n">percentage</span><span class="o">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>   <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实<code>Employee.giveIncrementOf(percentage)</code>是一个返回值为void的静态方法。</p>

<p>测试代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Test</span>
</span><span class='line'>   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">shouldReturnTrueWhenIncrementOf10PercentageIsGivenSuccessfully</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">PowerMockito</span><span class="o">.</span><span class="na">mockStatic</span><span class="o">(</span><span class="n">Employee</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">PowerMockito</span><span class="o">.</span><span class="na">doNothing</span><span class="o">().</span><span class="na">when</span><span class="o">(</span><span class="n">Employee</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>      <span class="n">Employee</span><span class="o">.</span><span class="na">giveIncrementOf</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">EmployeeService</span> <span class="n">employeeService</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">EmployeeService</span><span class="o">();</span>
</span><span class='line'>      <span class="n">assertTrue</span><span class="o">(</span><span class="n">employeeService</span><span class="o">.</span><span class="na">giveIncrementToAllEmployeesOf</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="nd">@Test</span>
</span><span class='line'>   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">shouldReturnFalseWhenIncrementOf10PercentageIsNotGivenSuccessfully</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">PowerMockito</span><span class="o">.</span><span class="na">mockStatic</span><span class="o">(</span><span class="n">Employee</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">PowerMockito</span><span class="o">.</span><span class="na">doThrow</span><span class="o">(</span><span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">()).</span><span class="na">when</span><span class="o">(</span><span class="n">Employee</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>      <span class="n">Employee</span><span class="o">.</span><span class="na">giveIncrementOf</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">EmployeeService</span> <span class="n">employeeService</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">EmployeeService</span><span class="o">();</span>
</span><span class='line'>      <span class="n">assertFalse</span><span class="o">(</span><span class="n">employeeService</span><span class="o">.</span><span class="na">giveIncrementToAllEmployeesOf</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到该测试中使用了<code>PowerMockito.doNothing()</code>和<code>PowerMockito.doThrow()</code>。其中<code>PowerMockito.doNothing().when(Employee.class)</code>告诉PowerMock当调类<code>Employee</code>时啥也不要干，而<code>PowerMockito.doThrow(new IllegalStateException()).when(Employee.class)</code>则表示实际调用类Employee时抛一个异常。这样，我们的两个测试就覆盖了<code>giveIncrementToAllEmployeesOf()</code>方法的正常和异常两个方面，测试完成。</p>

<p>另外，如果我们使用<code>PowerMockito.mockStatic(Employee.class)</code>mock了Employee的所有静态方法，但是我们又想在测试中真实的调用某个其中一个方法，那么就可以使用<code>PowerMockito.when(...).thenCallRealMethod()</code>，例如我们想调用count的真实方法，就可以：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">PowerMockito</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">Employee</span><span class="o">.</span><span class="na">count</span><span class="o">()).</span><span class="na">thenCallRealMethod</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>更多关于PowerMock，请参见<a href="https://code.google.com/p/powermock/">官方文档</a>。例子中的详细代码，请参见<a href="https://github.com/jiamaoweilie/MockingStaticMothod">我的github</a>。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/10/30/model-in-color/">[彩色建模【译】](http://www.step-10.com/SoftwareDesign/ModellingInColour/index.html)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/10/07/chi-xu-ji-cheng-zhi-wo-jian-si/">持续集成之我见（四）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/29/chi-xu-ji-cheng-san/">持续集成之我见（三）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/28/chi-xu-ji-cheng-er/">持续集成之我见（二）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/27/chi-xu-ji-cheng/">持续集成之我见（一）</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
