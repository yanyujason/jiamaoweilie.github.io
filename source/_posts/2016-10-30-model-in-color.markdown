---
layout: post
title: "彩色建模【译】"
date: 2016-10-30 11:49:46 +0800
comments: true
categories:
---

[参见原文](http://www.step-10.com/SoftwareDesign/ModellingInColour/index.html)

使用面向对象语言的（如Java，C#, Objective-C）软件开发人员创建一系列相关的类来开发软件。每个类定义了不同类型的对象，各个对象之间相互合作，提供了软件所需的功能。

根据“单一职责原则”或者“关注点分离”原则，精心设计的类的对象做且只做一件事件。一些类体现了技术领域的概念，例如用户界面、页面、控件、数据库连接、搜索结果、事务、网络连接、服务、消息。另一些类体现了问题域（problem domain）的概念。问题域的关注点是软件的消费者或用户。例如，如果开发一个订单管理系统，我们将定义一些问题域的类来代表消费者、订单和产品。

我们称这些类为业务描述对象或者“真实世界”建模，但是他们有一个更加普遍接受的名称：问题域类（problem domain classes）或者单纯的领域类（domain classes）。

换句话说，问题域类映射的观念、思路和规则是软件开发中剥离了正在使用的具体技术到后留下的东西。它们形成了软件的心脏，是传统面向对象应用中最重要的逻辑层。

在多数基于组件或者面向服务的软件中，问题域类帮助推动业务服务和组件的定义和组织。它们还推动了问题域类用于组件或服务实现的设计。

不管是传统的，基于组件的，或者是面向服务的软件，几乎所有的现代软件架构都需要很多技术类来支持每个问题域类。如图1：

* 用户界面类（User interface classes），通常是传统MVC（Model-View-Controller）和命令模式（Command patterns）的变种，对应软件使用者对问题领域对象的显示和操作。
* 持久化类（Persistence classes），或者持久化机制（例如Hibernate，ADO.Net Entity Framework，and Core Data）的配置文件，用来处理问题域对象到文件或者关系型数据库的映射、存储、检索。
* 服务层类和它们的参数提供了其他组件和外部系统通过网络与问题域对象集成和交互的方法。

![PD Class](http://www.step-10.com/SoftwareDesign/ModellingInColour/images/PDClass.png)

图1. 一个PD类需要大量技术类的支持   

虽然不是所有的问题域类都需要如此多的技术类支持，但是有些重要的问题域类可能需要更多的支持。因为它们出现在多个视图，参与了多个服务，以不同的方式在多个时间点持久化。由于各个问题域类之间的关系和依赖，整个事情将更加复杂，例如销售给客户的产品或者供应商交付的项目。在不考虑任何相关的单元、集成、和系统测试类和脚本的情况下，问题域对象支持类的平均数量可以轻松到达十几个或者更多。

尽管有最佳实践的封装，通过支持类对问题域类的更改经常一波三折。小型重构（例如重命名操作）可以通过现代化的IDE工具自动化实现，例如Eclipse、NetBeans、Visual Studio、和 XCode等。更加重要的更改（例如删除属性，改变一对一关系对一对多，是关系双向）通常仍然需要人工更新和重新测试很多类、配置文件、和运行环境支持等。

虽然许多改变是不可避免的，但是学习那些能够帮助我们尽早识别出更强健的问题域类的模式或策略显然是非常必要的。这正是‘彩色建模（modeling in color）’技术提供的东西，它针对于商业和I.T.产业的组件和系统。

Peter Coad在以前关于面向对象分析、设计模式和策略的工作中创建了‘彩色建模’技术的雏形，并在随后几年做了深入研究和重新定义。1997年，该技术首次用于新加坡的一个Java技术栈的软件开发项目。1999年，Peter Coad，与合著者Eric Lefebvre和Jeff De Luca，在他们出版的书《Java Modeling in Color with UML》中介绍了‘彩色建模’技术。对该技术和相关FDD（Feature-driven development）流程的贡献者还有Phil Bradley、Jon Kern、Mark Mayfield、David North和我。

**类建模**

彩色建模的模型和策略源于类建模的想法。

在业务系统，不论在什么领域，那些典型的问题域类总会一直出现。举个例子，我们几乎总是能发现一些代表不同类别业务（例如销售、订单、租赁、订票、计划的事件，交付，提交，批准，查询等）的交易或交互的类。然后，我们通常找到塑造了参与这些业务交易或交互的当事人、地点和事务的类，进行购买、销售、订购、批准等的人或者组织。此外，那些被购买、销售、或批准的产品或服务等需要被展示，例如在商店、银行分行、网站等这些事情发生的地方。这些一般类不是特定于某一个域。无论问题域是银行业、保险业、零售业、制造业、人力资源、旅游业、交通运输业，还是什么别的，那些典型的类总是持续出现。不同种类的类是独立于领域的，他们是领域无关的（domain neutral）。

这些类不止出现在商业系统。在工业系统中，我们有类来建模特定类型的事件和时间间隔，例如传感器或开关的状态变化，进行测量的时间段，一件设备性能上升到特定阶段需要的时间等等。它们同样非常典型，当事人、地点、和事务类分别代表了传感器和设备本身、监管设备或问题的处理过程的操作员、以及不同种类设备的地点等等。

一个粗略分类中的所有类之间的相似性可能不够接近，不能被概括为一个有用的超级类或者Java/C#中的接口。然而，他们之间的相似性已经足以帮助指导我们设计中问题域类的选择和定义。在彩色建模中，我们称这些粗略分类叫类原型（class archetypes），术语原型据说代表了比较柔和的模式，因此是比刻板印象更合适的术语。彩色建模识别出四个类原型，并分别为其分配一种颜色。

![FourClassArchetypesLinkedBare](http://www.step-10.com/SoftwareDesign/ModellingInColour/images/FourClassArchetypesLinkedBare.jpg)

图2：彩色建模为问题域定义了四个类原型

四个类原型如图2所示：

* [时刻/间隔（Moment-Interval）](http://www.step-10.com/SoftwareDesign/ModellingInColour/Moment-Interval.html)类原型，用于模拟需要处理并跟踪业务和法律原因的事情，或者在某个时刻或者某个时间间隔发生的事情。[[Coad99]](http://www.step-10.com/Books/JMCUBook.html)

MI类原型的例子包括销售、租赁、订单、旅程、飞行、会议、预定、谋杀、传感器读取、报警激活等。

MI类原型是粉红色（淡红色）。它表示我们的软件感兴趣的事件，以及人物、地点、事件之间的交互和业务交易。

换句话说，如果发生，它是粉红色的！粉红色发生！

* [角色](http://www.step-10.com/SoftwareDesign/ModellingInColour/Role.html)类原型塑造了一个参与人（人或者组织）、地点或事件的参与方式。[[Coad99]](http://www.step-10.com/Books/JMCUBook.html)

角色类的示例包括申请人、账号持有人、审批人、领航员、收银员、客户、供应商、运营商等。

角色类是淡黄色的。它表示参与到软件（发生的）时刻间隔的人、地点、和事物被识别的方式。角色是我们能够做到和授权的一组责任和义务。当我们希望演绎某种角色的时候，我们通常说我们带了一种或者多种不同的帽子。角色类塑造了这些帽子，并且这些帽子总是黄色的。

我们带黄帽子哦！

* [PPT（Party, Place, Thing）](http://www.step-10.com/SoftwareDesign/ModellingInColour/PartyPlaceThing.htm)类原型演绎了某些扮演不同角色的人或者物。[[Coad99]](http://www.step-10.com/Books/JMCUBook.html)

当事人(Party)类的例子是人或者组织。地点类的例子包括办公室、商店、仓库、机场、银行分行等。事物类是那些识别诸如私人汽车、飞机、DVD、书籍、设备等个体物品的类。

PPT类是淡绿色的。如果角色类是可以戴的各式各样的（黄色）帽子，那么PPT类就是戴那些帽子的人。显而易见，人是可以扮演角色的，但是地点也同样可以。一个建筑物可以扮演餐厅的角色，也可以扮演犯罪现场的角色。同样，事物也可以扮演角色，比如在制造过程中的角色，或者在销售过程中的角色。如果你可以与它交谈、被它带到法庭、移动它、踢它，那么这个东西就很可能是一个绿色的PPT类。

帽子是黄色的，但是戴帽子的家伙是绿色的哦！

* [描述](http://www.step-10.com/SoftwareDesign/ModellingInColour/Description.html)类原型塑造了一个类条目式（catalog-entry-like）的描述。它是一个一次又一次被应用的值得集合。它还提供对于对其描述的所有事物的集合的行为。[[Coad99]](http://www.step-10.com/Books/JMCUBook.html)

它的例子代表了所有类型的产品描述。蓝色和绿色之间的区别是电影和记录电影的DVD之间的区别。

描述类是淡蓝色的。描述类根据不同的值区分或者标记其他东西，通常这些东西是当事人、地点或者事物对象，偶尔也会有MI类。公司工作的行业是一个描述类对象。展厅中展示的汽车模型是一个描述类对象。亚马逊上销售的图书是一个描述类对象。

类似的，你用来区分这些东西的标签总是蓝色的哦！

**典型责任**

因为同一类原型基本上塑造相同的事物，他们的对象通常需要记住相同的信息，并执行类似的任务。举个例子，MI类的对象通常记录事物发生的日期和时间，并告诉您是否成功完成。角色类的对象通常需要记住它们已经被授权执行某种角色的某种标识符，比如飞行员的许可证号等。

通过列举大量各个类原型的例子，经过稍微的概括，我们可以为每个类原型创建一个典型操作和属性的粗略清单。列表中的每个属性或者操作都代表了我们为该类原型定义的典型操作或属性（见图3）。

![FourArchetypesWithContentSideBySide](http://www.step-10.com/SoftwareDesign/ModellingInColour/images/FourArchetypesWithContentSideBySide.gif)

图3：四个类原型及其典型属性和操作

很少有某个特定的模型能够列举该类原型所拥有的全部属性或者操作。如果某个特定的典型属性或操作与一个特定的类不相关，我们就简单的不为该类定义相应的属性或者操作。例如，对于有些需要相对优先级概念的MI类，我们就会有优先级属性的等价物，而对于没有该属于的类，我们就不做定义。

类原型的每个典型属性或者操作可能匹配特定类上的多个属性或操作。例如，一个具有复杂生命周期的MI类可能同时需要最大和最小状态属性。

这些典型属性或者操作列表也不是详尽的。我们定义的类将涉及一些不在相关原型列表中的属性或者操作。例如，一个当事人类中构建的对象可能包含一个保留日期，来指示由于某些法律需求，数据必须在何时被销毁。而PPT类中并不存在该属性。

这些类原型的典型属性和操作，只是为我们实际在定义类时需要的属性和操作提供了特定建议。它们为我们在创建或者审视一个类应属于某个类原型提供了线索和暗示。

换句话说，类原型的每个操作或属性是一个对特定类原型的典型责任的提示。如果我们可以识别出问题域中的类原型类，那么这些典型的操作和属性列表就提供给我们一个检查列表，来帮助我们来或在我们的模型中审查承担合适地责任。例如，每个类原型中的第一个属性是某种标示或者参考号码。这提示我们，属于任何类原型的对象都有责任使他们与其所代码的真实世界相匹配。例如，现金销售对象通常将收据编号作为参考编号，使其可以与其完成特定交易相匹配。出纳员对象可能需要记住用户名来匹配他们在其登录时的人类对象，等等。

事实上，类原型具有名称，典型属性列表和典型操作类别使用统一建模语言（UML）以图像的方式来表示类原型。我们会重复利用图3所示的一些属于原型类的标记。

**原型建模**

为了重复履行其职责，对象需要频繁的与同一个或者不同类之间的对象合作。因此，原型类中的许多典型责任意味着与其他类的典型关联，和与其他类的对象之间的典型交互方式。这些典型关联和它们对象之间的典型交互方式使得我们能够将类原型合并成原型、问题域对象模型。这些模型原型或者中立域组件作为我们分析和定义模型的常用模式。

![FourClassArchetypesLinked](http://www.step-10.com/SoftwareDesign/ModellingInColour/images/FourClassArchetypesLinked.jpg)

图4：四类原型链接到基本模型原型

![DNC](http://www.step-10.com/SoftwareDesign/ModellingInColour/images/DNC.gif)

图5：基本模型原型将参与人、地点、事件中扩展的详细中立域组件

使用中立域组件（Domain Neutral Component (DNC)）可以真正帮助我们提高构建问题域对象模型的速度。从识别感兴趣的特定问题域中的一个或多个时刻间隔类开始，然后依次对这些类使用DNC覆盖，逐步利用DNC中的条目替换特定问题域中条目，或者删除问题域中没有等价物的条目或模型不需要的条目。

DNC在审查现有模型中也非常有用。首先，通过分配原型到每个类来在模型中显示颜色。然后调整和证明DNC中的偏差和遗漏。但是，请记住，DNC是一种模型，但不是元模型（meta-model）。元模型定义了一系列创建兼容模型的严格规则。DNC不是这样的，它更加宽松，是一套建议和提示。在许多情况下，一些与模型的合理偏差是需要、期望、和必要的。

* [阅读更多关于原型使用和DNC的材料...](http://www.step-10.com/SoftwareDesign/ModellingInColour/dnc.html)

当我们第一次遇到它时，很多人对DNC在实践中的适用性提出了怀疑。我也拥有同样的问题。有两个原因使得我认为DNC比初始预期的更加适用。首先，大多数的商业系统都适用于特定的商业事件或活动，或者某种商业流程的事件或活动。MI模型就塑造了这些商业事件和活动。对于每个商业事件和活动，通常以不同的方式设计不同的人或组织。这些事件和活动通常发生在某些地方，即使是在网络空间。商业事件和活动经常涉及购买、销售、分配和移动东西。角色、当事人、地点、事件塑造了谁，在哪里，和那种形式的商业事件和活动。描述模型塑造了当事人、地点、事物在商业活动中的不同集合或分类。另外，重点第一是MI，其次是角色，角色扮演者，和帮助防止集中倾向于中心事件和在更加传统实体关系图（Entity-Relationship Diagramming (ERD)）中集中更多角色扮演者的描述。

第二个DNC比预期更加合适的原因是我在与来自TogetherSoft，Borland和Karl Frank的一个老同事讨论是出发的一些灵感。当你退一步思考后，你会意识到DNC本质上是PPT之间的UML关联的自然扩展。MI在许多方面类似于关联类的想法，角色类与关联末端发现的角色名称的想法类似。

* [阅读更多关于DNC和UNL的关联关系...](http://www.step-10.com/SoftwareDesign/ModellingInColour/FromUMLAssociationToDNC.html)

与[《Java Modeling in Color with UML》](http://www.step-10.com/Books/JMCUBook.html)书中提到的相比，近些年，我又补充了关于DNC的小改动，[阅读更多关于这些修改...](http://www.step-10.com/SoftwareDesign/ModellingInColour/DNCChanges.html)

**彩色建模法**

尽管在没有颜色的情况下类和模型原型也可以很有效，但是颜色编码为该技术命名。实践中证明，颜色编码是非常有效的，它可以有效减少我们使用它需要付出的代价。

色彩使得类原型更加易学易记。它还使得类原型在非平凡（non-trivial）UML类和序列图中更容易识别。当你初次或者比较少接触对象建模，如果呈现出一个复杂的图表会特别难以理解，而色彩将使得这些图表变得易于理解。它使得诸如项目消费者和终端用户可以更好的在建模过程中做出贡献。例如，他们可以很快识别和集中精力在粉红色的MI类所代表的他们感兴趣的业务交互中，并由此展开工作。

对象建模技术带来的最大好处是使得表达复杂分析和设计更加容易（上世纪90年代后期以及UML2.0规范中的那些冗长，太过于细节的建模方式中很容易被丢失和忘记的模型）。对色彩的使用能够显著增加用UML类图和时序图沟通时的能力。

对于那些关注为什么用彩色建模可以很好工作的人，[彩色建模法](http://www.step-10.com/SoftwareDesign/ModellingInColour/ColourCoding.html)还有一些关于如何使用颜色，每种颜色代表哪种类原型的讨论。

对于大多数人来说，学习并记得下面这四种色彩就已经足够了：

MI类是柔和的粉红色。粉红色的发生！

角色类是柔和的黄色。我们总是带着黄色的帽子！

PPT类是柔和的绿色。戴黄帽子的家伙们都是绿的的！

描述类是柔和的蓝色。你给东西打上蓝色的标签！
